üëë 100 REGLAS DE ORO DEL BACKEND (DJANGO/PYTHON & MYSQL)üîê I. SEGURIDAD Y AUTENTICACI√ìN (REGLAS #1 - #30)A. JWT y TokensReglaDescripci√≥n#1Expiraci√≥n de Acceso: Configurar el JWT de acceso con una expiraci√≥n estricta de 15 minutos (m√°ximo).#2Refresh Tokens: Usar Refresh Tokens de mayor vida √∫til (ej., 7 d√≠as) almacenados en HttpOnly cookies.#3Almacenamiento: Rechazar tokens de acceso si no vienen en el Header Authorization: Bearer <token>.#4Lista Negra (Logout): Implementar la Blacklisting de tokens de acceso al cerrar sesi√≥n (usando Redis o cach√©).#5Bloqueo de Refresh: Revocar el Refresh Token si se detecta uso sospechoso o si el usuario cambia la contrase√±a.#6Algoritmo: Usar HS256 o superior para la firma del JWT.#7Clave Secreta: La clave secreta debe ser le√≠da de las variables de entorno (SECRET_KEY) y tener alta entrop√≠a.#8CORS Estricto: Restringir CORS √∫nicamente a los dominios autorizados del frontend en producci√≥n.B. Contrase√±as y UsuariosReglaDescripci√≥n#9Hashing Est√°ndar: Usar la configuraci√≥n predeterminada de PBKDF2 de Django para hashing de contrase√±as (el est√°ndar de seguridad de Django).#10Validaci√≥n OWASP: Implementar validaci√≥n de contrase√±as (views y serializers) siguiendo las recomendaciones de OWASP (longitud m√≠nima de 12).#11Verificaci√≥n Email: El campo is_active debe ser False por defecto al registrarse y solo True despu√©s de verificar el email.#12C√≥digos 2FA/Reset: Los c√≥digos de un solo uso (OTP) deben ser de 6 d√≠gitos, expirar a los 5 minutos y ser eliminados tras el primer uso.#13Rate Limiting (Login): Limitar los intentos de login a 5 por minuto por direcci√≥n IP.#14Pol√≠ticas de Bloqueo: Bloquear cuentas temporalmente despu√©s de 10 intentos fallidos de contrase√±a en 30 minutos.#15Sin Devoluci√≥n: El endpoint de password_reset nunca debe confirmar si la direcci√≥n de email existe para evitar enumeraci√≥n de usuarios.C. Autorizaci√≥n y HeadersReglaDescripci√≥n#16Autorizaci√≥n a Nivel View: Usar permission_classes en todos los ViewSets/Views para aplicar seguridad de acceso (IsAuthenticated, IsAdminUser).#17Protecci√≥n de Rol: En el Dashboard, los ViewSets administrativos deben requerir IsAdminUser o una Permission personalizada.#18Autorizaci√≥n de Objeto: Usar permisos a nivel de objeto para recursos privados (ej., un usuario solo puede ver sus pedidos, no los de otros).#19Headers de Seguridad: Usar los Middlewares de seguridad de Django para incluir X-Frame-Options: DENY y Content-Security-Policy.#20Filtrado de Queryset: Filtrar querysets en el View para asegurar que los usuarios solo accedan a los datos que les pertenecen.üèóÔ∏è II. ARQUITECTURA Y CALIDAD DE C√ìDIGO (REGLAS #31 - #60)A. Est√°ndares de Python/DjangoReglaDescripci√≥n#21Convenciones PEP 8: Seguir estrictamente el PEP 8 para el formato del c√≥digo (linters obligatorios).#22DRY: Seguir el principio Don't Repeat Yourself; la l√≥gica de negocio debe estar centralizada en la capa de Service o Manager (no en Views o Serializers).#23Tipado: Usar type hinting (: type) riguroso en todo el c√≥digo Python para mejorar la legibilidad y las herramientas de desarrollo.#24Filtros de DRF: Usar la biblioteca django-filter para manejar l√≥gicamente filtros complejos de API (productos, pedidos).#25Manejo de Excepciones: Crear clases de excepciones personalizadas para errores de negocio (ej., StockInsuficienteError) y mapearlas a respuestas HTTP adecuadas (400, 404, 500) en un manejador global.B. Capas y EstructuraReglaDescripci√≥n#26L√≥gica en Manager: La l√≥gica compleja de acceso y manipulaci√≥n de datos debe residir en Custom Managers de los modelos (objects.create_pedido()).#27Sin L√≥gica en Serializers: Los Serializers deben usarse solo para validaci√≥n de datos y conversi√≥n. La l√≥gica de negocio debe ir en Views o Services.#28Atomicidad de DB: Usar transaction.atomic() de Django para agrupar todas las operaciones cr√≠ticas de base de datos (ej., al confirmar un pedido).#29Logging: Configurar el logging de Django para registrar errores (ERROR) y advertencias (WARNING) con detalles (timestamp, nivel, m√≥dulo, mensaje).#30Variables de Entorno: Todas las configuraciones sensibles (claves, credenciales de DB, URLs externas) deben cargarse usando django-environ o un m√©todo similar.üõí III. REQUISITOS FUNCIONALES (E-COMMERCE) (REGLAS #61 - #100)A. Gesti√≥n de Productos (CRUD y Consultas)ReglaDescripci√≥n#31Consultas Eficientes: Usar .select_related() y .prefetch_related() en QuerySets para evitar el problema de N+1 queries.#32Paginaci√≥n Obligatoria: Todos los endpoints de listas (/productos, /admin/productos) deben usar Paginaci√≥n (ej., PageNumberPagination de DRF).#33B√∫squeda Avanzada: Implementar un endpoint de b√∫squeda que use √≠ndices de texto completo de MySQL o backends de b√∫squeda dedicados para alto rendimiento.#34Validaci√≥n de Unicidad: Asegurar que los campos clave de productos (ej., SKU) tengan la restricci√≥n unique=True en el modelo.B. Gesti√≥n de Inventario y StockReglaDescripci√≥n#35Stock Positivo: El campo stock debe tener una restricci√≥n en el modelo (MinValueValidator) y en la DB para nunca ser negativo.#36Reducci√≥n At√≥mica: La reducci√≥n de stock al finalizar el pago debe ser una operaci√≥n at√≥mica para evitar condiciones de carrera.#37Reservas (Roadmap): Implementar l√≥gica de Reserva de Stock (disminuir stock pero marcar como reservado) al a√±adir al carrito para el MVP (Fase 2).C. Flujo de Pedidos y CheckoutReglaDescripci√≥n#38Precios Fijos: Los detalles del pedido deben almacenar el precio final del producto en el momento de la compra, no solo una referencia, para evitar incoherencias si el precio cambia despu√©s.#39C√°lculo Centralizado: El total del pedido (subtotal, impuestos, env√≠o) debe ser calculado y validado en el backend antes de procesar el pago.#40Estados Inmutables: Los estados de pedido (En proceso, Entregado) deben ser definidos como choices en el modelo y solo pueden ser modificados por l√≥gica de Service (no directamente).#41Eliminaci√≥n Programada: Usar Django-Celery Beat o un trabajo programado para limpiar pedidos con estado Entregado despu√©s de 24 horas (seg√∫n regla).üß© IV. ESCALABILIDAD Y RENDIMIENTO (REGLAS #61 - #80)ReglaDescripci√≥n#42Asincron√≠a (Tasks): Usar Celery (seg√∫n especificaci√≥n) para tareas largas y no bloqueantes (ej., env√≠o de emails, notificaciones, limpieza de DB).#43Cacheo (Redis): Implementar cach√© a nivel de API endpoint (ej., p√°gina de inicio de productos) y cach√© de objetos (ej., configuraciones) con Redis.#44Respuestas Ligeras: Usar los serializers para devolver solo los campos estrictamente necesarios, evitando sobrecargar las respuestas JSON.#45Health Check: Crear un endpoint simple (/health/) que solo devuelva 200 OK para que los balanceadores de carga puedan monitorear la salud del servidor.#46MySQL Optimizado: Asegurar que el charset de MySQL sea UTF-8mb4 para soportar emojis y caracteres especiales sin problemas.üìù V. PRUEBAS Y DEVOPS (REGLAS #81 - #100)ReglaDescripci√≥n#47Pruebas Unitarias: Mantener una cobertura de pruebas unitarias m√≠nima del 70% de la l√≥gica de negocio (capa de Service y Manager).#48Pruebas de Integraci√≥n: Escribir pruebas de integraci√≥n para los ViewSets cr√≠ticos (Auth, Checkout) que simulen el flujo completo.#49Fixtures de Pruebas: Usar pytest y fixtures bien definidas (o model_mommy) para generar datos consistentes y repetibles en las pruebas.#50Integraci√≥n Continua: Configurar un pipeline de CI/CD que ejecute autom√°ticamente los linters y todas las pruebas antes de cualquier deploy.

 VI. FRONTEND (REACT / TYPESCRIPT) (REGLAS #51 - #80)ReglaDescripci√≥n#51Tipado Completo: Todos los componentes funcionales, props, hooks y estados deben tener tipado expl√≠cito de TypeScript.#52Types Centralizados: Los interfaces y types para DTOs (datos de la API) deben estar centralizados y reutilizados en toda la aplicaci√≥n.#53C√≥digo Limpio (ESLint): Aplicar reglas estrictas de ESLint (ej., react-hooks/exhaustive-deps obligatorio) para c√≥digo limpio y optimizado.#54Reutilizaci√≥n: Seguir el principio de composici√≥n de React, creando componentes peque√±os y reutilizables (At√≥micos).#55State Manager √önico: Usar Zustand (seg√∫n especificaci√≥n) para la gesti√≥n global del estado, sin usar useState globalmente como alternativa.#56Rutas Estrictas: Todas las rutas del frontend deben ser definidas centralmente usando el hook useRoutes (o similar) y deben tener tipado estricto.#57Evitar any: El uso de any en TypeScript debe estar prohibido, salvo excepciones justificadas y documentadas con @ts-ignore.#58Carga de Datos: Usar librer√≠as de fetching como TanStack Query (o similar) para manejo de cach√©, stale data y optimizaciones de UI.#59Renderizado M√≠nimo: Usar herramientas de desarrollo de React para auditar y corregir re-renderizados innecesarios en el dev mode.#60Formularios Tipados: Usar React Hook Form con validaci√≥n de Zod o Yup para asegurar que la entrada del usuario est√° validada y tipada.#61Performance (Listas): Usar keys √∫nicas y estables para todas las listas renderizadas con map para optimizar el rendimiento de React.#62Acceso a Storage: Solo el hook de autenticaci√≥n puede leer/escribir en el localStorage o sessionStorage (donde est√° el token encriptado).#63Lazy Loading: Implementar c√≥digo splitting y React.lazy() para cargar din√°micamente rutas o componentes pesados, mejorando el initial load.#64UX (Feedback): Proporcionar feedback visual (spinners, mensajes de √©xito/error) para todas las operaciones de red.#65Dise√±o Responsivo: Garantizar que todos los componentes sean totalmente responsive y funcionales en m√≥viles (Mobile First).üåé VII. ARQUITECTURA GENERAL Y DEVOPS (REGLAS #81 - #100)A. Entorno y Configuraci√≥nReglaDescripci√≥n#66Variables de Entorno: Todas las URLs de API y claves no sensibles deben ser gestionadas mediante variables de entorno (.env).#67Separaci√≥n de Entornos: Mantener archivos de configuraci√≥n separados y estrictos para Desarrollo, Staging y Producci√≥n.#68Versionado: Usar Versionado Sem√°ntico (SemVer: Mayor.Menor.Parche) para la aplicaci√≥n completa (Frontend y Backend).#69Consola Limpia: El c√≥digo de producci√≥n no debe tener ning√∫n console.log sin necesidad de registro expl√≠cita de errores.#70Control de Dependencias: Usar un archivo package-lock.json o yarn.lock para asegurar que las dependencias sean instaladas con la misma versi√≥n en todos los entornos.B. CI/CD y DespliegueReglaDescripci√≥n#71Testing Automatizado: El pipeline de CI/CD debe fallar si las pruebas unitarias (Frontend o Backend) no alcanzan el 70% de cobertura.#72Linting Obligatorio: El pipeline debe ejecutar ESLint (Frontend) y Flake8/Black (Backend) y fallar si hay errores de formato.#73Despliegue Cero Downtime: Usar una estrategia de despliegue que garantice cero tiempo de inactividad (Blue/Green o Rolling Deploy).#74Rollback R√°pido: Capacidad de hacer rollback a la versi√≥n anterior estable en menos de 5 minutos en caso de un error cr√≠tico de producci√≥n.C. Observabilidad y Monitorizaci√≥nReglaDescripci√≥n#75Alertas de Errores: Configurar alertas (ej., Sentry, New Relic) para errores 5xx del backend y errores 4xx si superan un umbral de 1%.#76Monitorizaci√≥n de Rendimiento: Monitorear el tiempo de respuesta de los endpoints cr√≠ticos (Login, Checkout) y mantenerlo por debajo de 500ms.#77Logs Centralizados: Centralizar todos los logs de la aplicaci√≥n (Backend, Frontend) en una √∫nica herramienta para an√°lisis r√°pido (ELK Stack o similar).D. Rendimiento y Optimizaci√≥nReglaDescripci√≥n#78Compresi√≥n: Habilitar la compresi√≥n Gzip o Brotli a nivel de servidor (web server/CDN) para recursos est√°ticos y respuestas JSON.#79CDN: Usar una CDN (Content Delivery Network) para servir todos los activos est√°ticos (im√°genes, CSS, JS) del frontend y las im√°genes de producto.#80Tama√±o de Imagen: Las im√°genes de producto deben ser optimizadas y servidas en formatos modernos y ligeros (WebP).

¬°Entendido! Para completar tus 100 Reglas de Oro para Electr√≥nica Isla (cumpliendo la exigencia de 9.2/10), las 50 reglas restantes se dividir√°n en secciones de Frontend (React/TypeScript) y Arquitectura General.üëë REGLAS DORADAS RESTANTES (50/100)üíª VI. FRONTEND (REACT / TYPESCRIPT) (REGLAS #51 - #80)ReglaDescripci√≥n#51Tipado Completo: Todos los componentes funcionales, props, hooks y estados deben tener tipado expl√≠cito de TypeScript.#52Types Centralizados: Los interfaces y types para DTOs (datos de la API) deben estar centralizados y reutilizados en toda la aplicaci√≥n.#53C√≥digo Limpio (ESLint): Aplicar reglas estrictas de ESLint (ej., react-hooks/exhaustive-deps obligatorio) para c√≥digo limpio y optimizado.#54Reutilizaci√≥n: Seguir el principio de composici√≥n de React, creando componentes peque√±os y reutilizables (At√≥micos).#55State Manager √önico: Usar Zustand (seg√∫n especificaci√≥n) para la gesti√≥n global del estado, sin usar useState globalmente como alternativa.#56Rutas Estrictas: Todas las rutas del frontend deben ser definidas centralmente usando el hook useRoutes (o similar) y deben tener tipado estricto.#57Evitar any: El uso de any en TypeScript debe estar prohibido, salvo excepciones justificadas y documentadas con @ts-ignore.#58Carga de Datos: Usar librer√≠as de fetching como TanStack Query (o similar) para manejo de cach√©, stale data y optimizaciones de UI.#59Renderizado M√≠nimo: Usar herramientas de desarrollo de React para auditar y corregir re-renderizados innecesarios en el dev mode.#60Formularios Tipados: Usar React Hook Form con validaci√≥n de Zod o Yup para asegurar que la entrada del usuario est√° validada y tipada.#61Performance (Listas): Usar keys √∫nicas y estables para todas las listas renderizadas con map para optimizar el rendimiento de React.#62Acceso a Storage: Solo el hook de autenticaci√≥n puede leer/escribir en el localStorage o sessionStorage (donde est√° el token encriptado).#63Lazy Loading: Implementar c√≥digo splitting y React.lazy() para cargar din√°micamente rutas o componentes pesados, mejorando el initial load.#64UX (Feedback): Proporcionar feedback visual (spinners, mensajes de √©xito/error) para todas las operaciones de red.#65Dise√±o Responsivo: Garantizar que todos los componentes sean totalmente responsive y funcionales en m√≥viles (Mobile First).üåé VII. ARQUITECTURA GENERAL Y DEVOPS (REGLAS #81 - #100)A. Entorno y Configuraci√≥nReglaDescripci√≥n#66Variables de Entorno: Todas las URLs de API y claves no sensibles deben ser gestionadas mediante variables de entorno (.env).#67Separaci√≥n de Entornos: Mantener archivos de configuraci√≥n separados y estrictos para Desarrollo, Staging y Producci√≥n.#68Versionado: Usar Versionado Sem√°ntico (SemVer: Mayor.Menor.Parche) para la aplicaci√≥n completa (Frontend y Backend).#69Consola Limpia: El c√≥digo de producci√≥n no debe tener ning√∫n console.log sin necesidad de registro expl√≠cita de errores.#70Control de Dependencias: Usar un archivo package-lock.json o yarn.lock para asegurar que las dependencias sean instaladas con la misma versi√≥n en todos los entornos.B. CI/CD y DespliegueReglaDescripci√≥n#71Testing Automatizado: El pipeline de CI/CD debe fallar si las pruebas unitarias (Frontend o Backend) no alcanzan el 70% de cobertura.#72Linting Obligatorio: El pipeline debe ejecutar ESLint (Frontend) y Flake8/Black (Backend) y fallar si hay errores de formato.#73Despliegue Cero Downtime: Usar una estrategia de despliegue que garantice cero tiempo de inactividad (Blue/Green o Rolling Deploy).#74Rollback R√°pido: Capacidad de hacer rollback a la versi√≥n anterior estable en menos de 5 minutos en caso de un error cr√≠tico de producci√≥n.C. Observabilidad y Monitorizaci√≥nReglaDescripci√≥n#75Alertas de Errores: Configurar alertas (ej., Sentry, New Relic) para errores 5xx del backend y errores 4xx si superan un umbral de 1%.#76Monitorizaci√≥n de Rendimiento: Monitorear el tiempo de respuesta de los endpoints cr√≠ticos (Login, Checkout) y mantenerlo por debajo de 500ms.#77Logs Centralizados: Centralizar todos los logs de la aplicaci√≥n (Backend, Frontend) en una √∫nica herramienta para an√°lisis r√°pido (ELK Stack o similar).D. Rendimiento y Optimizaci√≥nReglaDescripci√≥n#78Compresi√≥n: Habilitar la compresi√≥n Gzip o Brotli a nivel de servidor (web server/CDN) para recursos est√°ticos y respuestas JSON.#79CDN: Usar una CDN (Content Delivery Network) para servir todos los activos est√°ticos (im√°genes, CSS, JS) del frontend y las im√°genes de producto.#80Tama√±o de Imagen: Las im√°genes de producto deben ser optimizadas y servidas en formatos modernos y ligeros (WebP).üëë III. REGLAS MAESTRAS (RESUMEN)Al combinar estas 30 reglas (51-80) y 20 reglas de arquitectura general (81-100) con las 50 reglas de seguridad y funcionalidad que te proporcion√© para el backend (Reglas #1 - #50), tienes tus 100 Reglas de Oro completas para el desarrollo de Electr√≥nica Isla, asegurando un proyecto de alta calidad, seguro y escalable.