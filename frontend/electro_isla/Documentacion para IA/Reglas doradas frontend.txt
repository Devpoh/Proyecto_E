Aqu√≠ tienes la primera tanda de 50 prompts, cubriendo las primeras categor√≠as de reglas generales, backend y seguridad que te di, transformadas en instrucciones precisas:

Primera Tanda de 50 Prompts

Categor√≠a: Principios Generales y de C√≥digo

Regla: Regla de Oro para Optimizaci√≥n de C√≥digo y Estructura de Proyecto
"Como IA experta en an√°lisis de c√≥digo y optimizaci√≥n de proyectos, tu misi√≥n es examinar meticulosamente la carpeta que te indicar√©, con el objetivo de identificar, verificar y eliminar de forma segura c√≥digo muerto, c√≥digo en desuso, archivos redundantes y carpetas vac√≠as que puedan afectar el rendimiento o el mantenimiento del proyecto.
Procedimiento Riguroso de An√°lisis y Eliminaci√≥n:
Exploraci√≥n Completa: Inicia un escaneo recursivo de cada archivo y subcarpeta dentro del directorio ra√≠z proporcionado.
Identificaci√≥n Preliminar de Candidatos:
C√≥digo Muerto/En Desuso: Analiza el contenido de cada archivo de c√≥digo (ej. .js, .py, .java, .cpp, .php, .html, .css, etc.) para identificar funciones, clases, variables o bloques de c√≥digo que no sean llamados, importados, referenciados o utilizados en ning√∫n otro lugar del proyecto. Presta especial atenci√≥n a:
Funciones o m√©todos no invocados.
Variables declaradas pero no le√≠das.
Importaciones no utilizadas.
Bloques if/else con condiciones siempre falsas o verdaderas, que dejen ramas inaccesibles.
Archivos de configuraci√≥n o scripts antiguos que no parecen tener un prop√≥sito activo.
Archivos Redundantes: Busca archivos duplicados o archivos que contengan contenido id√©ntico a otros.
Carpetas Vac√≠as: Identifica cualquier carpeta que no contenga archivos ni subcarpetas.
Verificaci√≥n Exhaustiva (¬°200% de Seguridad!): Para cada candidato identificado en el paso 2:
Rastreo de Referencias Cruzadas: Realiza una b√∫squeda global dentro de todos los archivos del proyecto para verificar si el c√≥digo, archivo o carpeta candidato es referenciado, importado, llamado o utilizado de alguna manera. Considera nombres de funciones, rutas de archivos, nombres de clases, etc.
An√°lisis de Flujo de Ejecuci√≥n: Si es posible, simula o analiza el flujo de ejecuci√≥n para confirmar que el c√≥digo identificado nunca se alcanzar√° bajo ninguna circunstancia.
Contexto del Proyecto: Si hay archivos de construcci√≥n (ej. webpack.config.js, Makefile), scripts de despliegue, o archivos de configuraci√≥n, anal√≠zalos para asegurarte de que el candidato no forma parte de un proceso oculto o condicional.
Confirmaci√≥n Negativa: Solo si despu√©s de todas estas verificaciones no encuentras absolutamente ninguna referencia ni uso del candidato, considera que es seguro para la eliminaci√≥n.
Eliminaci√≥n Segura (Solo si es 200% seguro):
Una vez que est√©s 200% segura de que un fragmento de c√≥digo, un archivo o una carpeta cumple con los criterios de c√≥digo muerto/en desuso/vac√≠o y no tiene ninguna referencia activa en el proyecto, procede a su eliminaci√≥n.
¬°Prioridad: No Romper Nada! Si existe la m√°s m√≠nima duda sobre el uso de un elemento, no lo elimines. Es preferible conservar un poco de c√≥digo en desuso a introducir un error cr√≠tico.
Reporte Final:
Al finalizar el proceso, proporciona un informe detallado que incluya:
Una lista de todos los archivos y fragmentos de c√≥digo eliminados.
Una justificaci√≥n breve para cada eliminaci√≥n.
Una lista de cualquier archivo o c√≥digo que consideraste dudoso y decidiste no eliminar, con la raz√≥n.
¬°Tu objetivo principal es optimizar sin comprometer la funcionalidad ni la estabilidad del proyecto!"

Regla: ‚ö†Ô∏è Consideraciones de seguridad al usar Zod (y gesti√≥n de estado/rutas en frontend)

Validar todos los datos que vienen del exterior
Usa Zod para validar respuestas de APIs, incluso si vienen de tu propio backend.
Nunca conf√≠es ciegamente en que el backend o una API externa enviar√° datos en el formato correcto.

Zod no protege contra ataques, pero ayuda a prevenir errores que pueden abrir puertas
Por ejemplo, si no validas bien un formulario y env√≠as datos corruptos, podr√≠as generar un fallo de seguridad en el backend o en tu l√≥gica del cliente.

No asumas que un dato ya est√° limpio solo porque pas√≥ una validaci√≥n
Zod valida estructura y tipo, no contenido malicioso.
Un string como <script>alert('x')</script> puede pasar como un string v√°lido.
üîí Complementa con sanitizaci√≥n, especialmente si est√°s aceptando texto libre del usuario.

Zod no reemplaza la validaci√≥n del backend
Puedes usar Zod en Node.js, pero si usas Spring Boot, valida tambi√©n all√≠ (@Valid, @NotNull, etc.).
La validaci√≥n del cliente es solo una ayuda para la UX, no para la seguridad real.

Evita mostrar errores t√©cnicos de Zod al usuario final directamente
Mapea los errores a mensajes amigables. Exponer estructuras internas puede dar pistas a un atacante.

Cuida la performance de esquemas muy grandes o din√°micos
Zod es r√°pido, pero si tienes muchos niveles anidados o reglas complejas, prueba el rendimiento.

üõ°Ô∏è Consideraciones adicionales al usar Zustand + protecci√≥n de rutas (integraci√≥n con Zod)

Zustand no es una fuente confiable de seguridad
Es √∫til para manejar isAuthenticated, userRole, etc., pero esa informaci√≥n vive en memoria del cliente y puede ser manipulada f√°cilmente desde DevTools.

Guards de rutas deben ser solo una capa de experiencia, no de seguridad real
Puedes evitar que un usuario navegue a /admin, pero si el backend no verifica el rol, no sirve de nada.
‚û§ El backend debe verificar los permisos con tokens, roles y l√≥gica real.

Los roles y permisos deben provenir del backend
Nunca conf√≠es en lo que est√° almacenado en Zustand o cualquier estado del frontend para autorizar acciones cr√≠ticas.

El frontend debe limpiar el estado al cerrar sesi√≥n
Si usas Zustand para guardar informaci√≥n del usuario, aseg√∫rate de que se borre correctamente al hacer logout.

Tokens y credenciales no deben guardarse en Zustand ni en localStorage sin protecci√≥n
Usa HttpOnly cookies cuando sea posible, y aseg√∫rate de no exponer estos datos al JavaScript del cliente.

La protecci√≥n de rutas es una pr√°ctica √∫til, pero solo funciona bien cuando:

Se verifica la existencia y validez del token (por ejemplo, mediante una llamada /auth/me).

Se sincroniza el estado del frontend con la realidad del backend.

üõ°Ô∏è Buenas pr√°cticas con Zod

Define todos tus esquemas en un lugar com√∫n (schemas/, validators/, etc.) para que sean reutilizables.

Usa safeParse para evitar que errores de validaci√≥n exploten la app con excepciones.

Si validas respuestas de una API externa, lanza un error claro si el formato no es v√°lido (mejor explotar controladamente que aceptar datos corruptos).

Para inputs del usuario (formularios, comentarios, etc.), combina Zod con sanitizaci√≥n (por ejemplo, usando DOMPurify si es HTML).

Si usas Zod en el backend (ej: con Express), puedes generar esquemas compartidos (zod-to-json-schema) para evitar duplicaci√≥n entre frontend y backend.

üö´ Qu√© evitar
Pr√°ctica insegura	¬øPor qu√©?
Usar .parse() sin try/catch	Si el dato es inv√°lido, tirar√° una excepci√≥n sin manejar.
No validar las respuestas de APIs externas	Puedes introducir datos mal formados o maliciosos en tu app.
Mostrar error.message de Zod directamente al usuario	Puedes filtrar detalles internos o estructuras t√©cnicas innecesarias.
Guardar isAuthenticated, role o tokens sensibles en Zustand sin control	El usuario puede modificar este estado desde el navegador.
Confiar en guards de frontend como √∫nica protecci√≥n de rutas	El backend debe siempre validar la autorizaci√≥n real.
Asumir que pasar la validaci√≥n de Zod significa que el dato es "seguro"	Puede contener scripts, SQL injection u otro contenido malicioso.

Regla: ‚ö†Ô∏è Consideraciones de seguridad al usar Axios:

No pongas tokens sensibles directamente en el c√≥digo

Nunca hardcodees tokens o claves de API en archivos del frontend.

Usa variables de entorno (.env) y aseg√∫rate de que lo que expones en el cliente est√© pensado para el cliente (por ejemplo, no incluyas secretos de backend).

Usa https:// en todas las peticiones

Evita enviar datos por http://, ya que se pueden interceptar f√°cilmente (man-in-the-middle).

Aseg√∫rate de que el backend tenga un certificado SSL v√°lido.

Configura correctamente los interceptores

Puedes usar interceptores para a√±adir cabeceras (como tokens JWT), manejar errores globales, etc.

Aseg√∫rate de limpiar los tokens y cancelar peticiones si el usuario cierra sesi√≥n.

No agregues tokens a dominios de terceros por error.

Protege los datos sensibles en tr√°nsito

No env√≠es datos personales sin encriptaci√≥n si no es necesario.

Aunque se use HTTPS, cuida qu√© datos mandas en headers, URL params o cuerpo.

Manejo adecuado de errores y respuestas

No expongas mensajes de error del backend directamente al usuario sin sanitizar.

Evita mostrar informaci√≥n sensible (como trazas de error internas) en el frontend.

Limita el tama√±o de las respuestas y peticiones

Axios permite recibir respuestas grandes. Si no controlas eso, puedes exponerte a DoS (Denial of Service) en ciertos escenarios.

CORS y CSRF no dependen de Axios, pero interact√∫an con √©l

Aseg√∫rate de configurar correctamente el backend para manejar CORS y proteger contra CSRF si usas cookies para autenticar.

üõ°Ô∏è Buenas pr√°cticas recomendadas

Centraliza la configuraci√≥n de Axios en un archivo com√∫n (shared/api/axios.ts, por ejemplo).

Usa interceptores para manejar tokens y errores, pero con validaciones claras.

Elimina tokens del almacenamiento cuando el usuario cierre sesi√≥n.

Si usas autenticaci√≥n basada en tokens, gu√°rdalos en cookies con HttpOnly siempre que puedas (esto requiere ajustes en el backend).

Implementa l√≥gica para renovar tokens de forma segura (refresh tokens).

Usa headers personalizados solo si sabes que el backend los espera y los valida correctamente.

üö´ Qu√© evitar
Pr√°ctica insegura	¬øPor qu√©?
axios.defaults.headers.common['Authorization'] = token; en cualquier parte del frontend	Expones tokens de forma global, incluso para dominios externos.
Guardar tokens en localStorage sin protecci√≥n	Facilita ataques XSS si hay alguna vulnerabilidad.
Mostrar error.response.data directamente en la UI	Puedes exponer detalles internos del backend.

Regla: ‚ö†Ô∏è Consideraciones de seguridad al usar Zustand:

No guardes informaci√≥n sensible en el estado global del cliente

Ejemplos de datos sensibles: tokens JWT, contrase√±as, datos personales identificables (DPI), etc.

El estado en el cliente es f√°cilmente inspeccionable desde el navegador (DevTools), por lo tanto, no lo trates como un lugar seguro.

Ten cuidado con la persistencia del estado

Zustand tiene middlewares que permiten persistir el estado en localStorage o sessionStorage.

Si decides persistir, encripta y limita la informaci√≥n. No guardes datos sensibles sin protecci√≥n.

Revisa bien qu√© datos se est√°n serializando.

Protege el acceso a funcionalidades cr√≠ticas

Zustand puede almacenar una bandera como isAuthenticated, pero no debe ser la √∫nica barrera de seguridad.

Las protecciones reales deben venir del backend (verificaci√≥n de tokens, roles, permisos, etc.).

Evita fugas de informaci√≥n

Aseg√∫rate de que Zustand no mantenga en memoria datos de usuarios anteriores (ej: si alguien cierra sesi√≥n, limpia el store correctamente).

Controla el acceso desde extensiones y scripts

Zustand expone el estado en memoria; si hay una extensi√≥n maliciosa o un script inyectado, puede leer esos datos.

Aunque esto es un riesgo general del frontend, evita exponer m√°s de lo necesario.

Usa middlewares con precauci√≥n

Zustand permite usar middlewares (logger, persist, devtools, etc.). Revisa si alguno introduce riesgos o si filtra datos.

üõ°Ô∏è Buenas pr√°cticas recomendadas

Usa Zustand solo para UI y estado no sensible (ej: men√∫s, flags, tema, carrito, etc.).

Usa cookies seguras (httpOnly) o almacenamiento seguro del lado del servidor para tokens de sesi√≥n.

Si persistes el estado, aplica una estrategia de limpieza al cerrar sesi√≥n.

No conf√≠es en el estado del cliente para decisiones de seguridad o autorizaci√≥n.

Mant√©n Zustand actualizado para evitar problemas conocidos o bugs.

Regla: Consejos para usar React Query de forma segura:

Nunca caches datos sensibles en React Query que puedan ser le√≠dos f√°cilmente por otros scripts.

Controla bien los tokens de autenticaci√≥n (ej. usa HttpOnly cookies cuando sea posible).

Maneja correctamente errores 401/403 para renovar o redirigir al login.

Usa HTTPS en producci√≥n para proteger datos en tr√°nsito.

Valida y sanitiza siempre en backend.

Regla: Es importante que cada vez que hagas un error no sigas a realizar otra tarea, quiero que soluciones ese error que realizaste para luego seguir con las otras tareas asi evitamos acumulacion de errores y desorden. Tienes prohibido crear un error y dejarlo sin solucion y seguir trabajando en otras cosas

Regla: Nombres de Archivos y Carpetas:
Todos los nombres deben ser en espa√±ol.
Deben ser descriptivos y reflejar claramente su contenido o responsabilidad.
Utiliza kebab-case para los nombres de carpetas y archivos (ej. listado-productos.tsx, servicio-usuarios.ts).
Los archivos que contienen componentes de React (o el framework elegido) deben usar la extensi√≥n adecuada (ej. .tsx o .jsx). Los archivos de l√≥gica pura o servicios pueden usar .ts o .js.
Nombres de Clases y Funciones:
Todos los nombres deben ser en espa√±ol.
Utiliza PascalCase para las clases y componentes (ej. BotonPrimario, ComponenteTarjetaProducto).
Utiliza camelCase para las funciones y variables (ej. obtenerDatosUsuario, validarFormulario).
Los nombres deben ser expl√≠citos y autodescriptivos, reflejando su prop√≥sito exacto.
Contenido de Ejemplo: Para cada archivo y funci√≥n/clase, incluye un esqueleto de c√≥digo b√°sico que demuestre su intenci√≥n. Por ejemplo:
Clases de componentes: un export default function ComponenteNombre() { return <div>...</div>; } simple.
Funciones de utilidad: un export function nombreFuncion() { /* l√≥gica */ } con un comentario.
Archivos de API: un export const obtenerRecurso = async () => { /* petici√≥n */ };
Tipos: export interface TipoEntidad { id: string; nombre: string; }
Modularidad y Encapsulaci√≥n: Aseg√∫rate de que las clases y funciones est√©n dise√±adas para ser reutilizables y con una √∫nica responsabilidad, encapsulando su l√≥gica.
Principios Generales: Incorpora los principios de c√≥digo limpio, DRY y legibilidad en los nombres y la estructura, todo en espa√±ol.

Regla: Tener en el proyecto una arquitectura Modular por Funcionalidad.src/
‚îú‚îÄ‚îÄ app/                    # Configuraci√≥n de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ providers/         # Context providers, store setup
‚îÇ   ‚îú‚îÄ‚îÄ styles/           # Estilos globales
‚îÇ   ‚îî‚îÄ‚îÄ index.tsx         # App entry point
‚îú‚îÄ‚îÄ pages/                 # P√°ginas de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ home/
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îú‚îÄ‚îÄ cart/
‚îÇ   ‚îî‚îÄ‚îÄ checkout/
‚îú‚îÄ‚îÄ widgets/              # Bloques de UI complejos
‚îÇ   ‚îú‚îÄ‚îÄ header/
‚îÇ   ‚îú‚îÄ‚îÄ footer/
‚îÇ   ‚îú‚îÄ‚îÄ product-catalog/
‚îÇ   ‚îî‚îÄ‚îÄ shopping-cart/
‚îú‚îÄ‚îÄ features/             # Funcionalidades de negocio
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ product-search/
‚îÇ   ‚îú‚îÄ‚îÄ add-to-cart/
‚îÇ   ‚îî‚îÄ‚îÄ payment/
‚îú‚îÄ‚îÄ entities/             # Entidades de negocio
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îú‚îÄ‚îÄ product/
‚îÇ   ‚îú‚îÄ‚îÄ order/
‚îÇ   ‚îî‚îÄ‚îÄ category/
‚îî‚îÄ‚îÄ shared/               # C√≥digo reutilizable
    ‚îú‚îÄ‚îÄ ui/               # Componentes UI b√°sicos
    ‚îú‚îÄ‚îÄ lib/              # Utilidades, helpers
    ‚îú‚îÄ‚îÄ api/              # Configuraci√≥n API
    ‚îî‚îÄ‚îÄ config/           # Configuraciones

Regla: Conoce tus Fundamentos: Domina HTML, CSS y JavaScript a fondo.

Prompt: Siempre utiliza las funcionalidades nativas de HTML, CSS y JavaScript cuando sea apropiado. Demuestra maestr√≠a en los fundamentos de la web.

Regla: Mant√©n el C√≥digo Limpio y Legible: Usa nombres de variables y funciones descriptivos, y sigue un estilo de codificaci√≥n consistente.

Prompt: Escribe c√≥digo con nombres de identificadores (variables, funciones, clases) que sean expl√≠citos y autodescriptivos. Aplica un estilo de formato uniforme (sangr√≠a, espaciado, comillas) en todo el proyecto.

Regla: No te Repitas (DRY): Refactoriza el c√≥digo duplicado en funciones o componentes reutilizables.

Prompt: Identifica y elimina la duplicaci√≥n de c√≥digo. Abstrae la l√≥gica repetida en funciones, componentes o m√≥dulos reutilizables.

Regla: Haz el C√≥digo Reutilizable: Dise√±a componentes y m√≥dulos que puedan usarse en diferentes partes de la aplicaci√≥n.

Prompt: Construye componentes y m√≥dulos con una interfaz bien definida y una l√≥gica encapsulada, dise√±ados para ser utilizados en m√∫ltiples contextos sin modificaciones.

Regla: Haz el C√≥digo Modular: Divide tu aplicaci√≥n en m√≥dulos peque√±os y manejables.

Prompt: Descompone la aplicaci√≥n en m√≥dulos cohesivos y de acoplamiento bajo, cada uno con una responsabilidad clara y √∫nica. Utiliza mecanismos est√°ndar de importaci√≥n/exportaci√≥n.

Regla: Escribe Comentarios Clares: Documenta el "por qu√©" de las decisiones de c√≥digo complejas, no solo el "qu√©".

Prompt: A√±ade comentarios al c√≥digo para explicar la l√≥gica compleja, las decisiones de dise√±o clave, los compromisos t√©cnicos o las razones de implementaciones no obvias. Evita comentar c√≥digo evidente.

Regla: Prioriza el Rendimiento: Optimiza los recursos (im√°genes, fuentes, CSS, JS) para tiempos de carga r√°pidos.

Prompt: Implementa t√©cnicas de optimizaci√≥n de rendimiento como compresi√≥n, minificaci√≥n, lazy loading de recursos y carga as√≠ncrona de scripts para asegurar una experiencia de usuario r√°pida.

Regla: Depura con Eficacia: Aprende a usar las herramientas de desarrollo del navegador para identificar y solucionar problemas r√°pidamente.

Prompt: Demuestra el uso efectivo de las herramientas de desarrollo del navegador (consola, depurador, panel de red, inspecci√≥n de elementos) para diagnosticar y resolver problemas de forma eficiente.

Regla: Mantente Actualizado: El ecosistema frontend cambia constantemente; aprende nuevas herramientas y pr√°cticas.

Prompt: Aplica las √∫ltimas caracter√≠sticas de los est√°ndares web (HTML, CSS, JavaScript) y las mejores pr√°cticas de las librer√≠as/frameworks populares, indicando el est√°ndar o la versi√≥n utilizada.

Regla: Practica la Arquitectura de Componentes: Piensa en tu UI como un √°rbol de componentes anidados.

Prompt: Estructura la interfaz de usuario como un √°rbol de componentes, donde cada uno tiene una responsabilidad √∫nica y se comunica de forma clara a trav√©s de props y eventos.

Categor√≠a: HTML

Regla: Usa HTML Sem√°ntico: Emplea las etiquetas HTML adecuadas para dar significado a tu contenido.

Prompt: Utiliza etiquetas HTML sem√°nticas (ej. <header>, <nav>, <main>, <article>, <section>, <footer>, <aside>) para estructurar el contenido seg√∫n su significado, no solo por su apariencia.

Regla: Valida tu HTML: Aseg√∫rate de que tu HTML sea v√°lido para evitar comportamientos inesperados y mejorar la accesibilidad.

Prompt: Genera HTML que cumpla con los est√°ndares de validaci√≥n de W3C. Evita errores de sintaxis o uso incorrecto de etiquetas y atributos.

Regla: Prioriza la Accesibilidad (ARIA): Haz tu contenido accesible para todos los usuarios, incluyendo aquellos que usan lectores de pantalla.

Prompt: Implementa atributos ARIA (ej. aria-label, aria-describedby, role), textos alternativos para im√°genes (alt), y asegura una navegaci√≥n de teclado coherente para garantizar la accesibilidad.

Regla: Optimiza las Etiquetas Meta: Utiliza las etiquetas meta adecuadas para SEO y la visualizaci√≥n en redes sociales.

Prompt: Incluye metaetiquetas esenciales (charset, viewport, description, keywords) y Open Graph/Twitter Cards para un SEO efectivo y una visualizaci√≥n atractiva en redes sociales.

Categor√≠a: CSS

Regla: Escribe CSS Escalable: Considera metodolog√≠as como BEM, SMACSS o CSS-in-JS para organizar tu CSS.

Prompt: Organiza el CSS utilizando una metodolog√≠a escalable (ej. BEM, CSS Modules, Styled Components) para evitar colisiones de nombres, mejorar la legibilidad y facilitar el mantenimiento.

Regla: Haz tu Dise√±o Responsivo: Aseg√∫rate de que tu sitio web se vea bien en todos los tama√±os de pantalla.

Prompt: Implementa un dise√±o responsivo utilizando media queries, Flexbox y/o CSS Grid para asegurar que la UI se adapte y funcione correctamente en todos los dispositivos y tama√±os de pantalla.

Regla: Evita el CSS Global Excesivo: Utiliza selectores espec√≠ficos o CSS Scope para evitar conflictos de estilos.

Prompt: Minimiza el uso de selectores CSS globales. Prefiere selectores espec√≠ficos, CSS con scope (ej. m√≥dulos CSS) o CSS-in-JS para encapsular estilos y prevenir efectos secundarios no deseados.

Regla: Minimiza la Especificidad CSS: Evita usar !important y selectores excesivamente espec√≠ficos.

Prompt: Escribe reglas CSS con la especificidad m√≠nima necesaria. Evita el uso de !important y selectores anidados profundos para mantener el CSS predecible y f√°cil de sobrescribir.

Regla: Usa Variables CSS (Custom Properties): Define colores, fuentes y espaciados para facilitar la consistencia y el mantenimiento.

Prompt: Define y utiliza variables CSS (propiedades personalizadas) para valores reutilizables como colores, tipograf√≠a, espaciados y tama√±os, facilitando la consistencia y cambios de tema.

Regla: Optimiza la Entrega de CSS: Considera el "critical CSS" para una carga m√°s r√°pida.

Prompt: Optimiza la entrega de CSS extrayendo y cargando el CSS cr√≠tico (necesario para el contenido visible inicial) de forma s√≠ncrona, y cargando el resto de forma as√≠ncrona o con lazy loading.

Categor√≠a: JavaScript

Regla: Entiende el Event Loop de JavaScript: Comprende c√≥mo funciona el asincronismo y la ejecuci√≥n de tareas.

Prompt: Al escribir c√≥digo as√≠ncrono, demuestra un claro entendimiento del Event Loop de JavaScript. Utiliza Promises y async/await de manera efectiva para gestionar operaciones no bloqueantes.

Regla: Manejo de Errores Robusto: Implementa try...catch y otras estrategias para manejar errores graciosamente.

Prompt: Implementa bloques try...catch para manejar errores en operaciones cr√≠ticas. Proporciona mensajes de error claros al usuario y mecanismos de recuperaci√≥n cuando sea posible.

Regla: Conoce ES6+ (ECMAScript): Familiar√≠zate con las caracter√≠sticas modernas de JavaScript.

Prompt: Utiliza las caracter√≠sticas modernas de ECMAScript (ES6+) como funciones flecha, const/let, desestructuraci√≥n, operadores spread/rest, async/await para escribir c√≥digo conciso y eficiente.

Regla: Optimiza el Rendimiento de JavaScript: Evita operaciones costosas en el hilo principal y minimiza el tama√±o de los bundles.

Prompt: Minimiza la carga de JavaScript en el hilo principal. Evita c√°lculos complejos o manipulaciones DOM intensivas en un solo ciclo, y optimiza el tama√±o del bundle de JavaScript.

Regla: Protege tu C√≥digo de Inyecciones (XSS): Sanea la entrada del usuario y ten cuidado al insertar contenido din√°mico en el DOM.

Prompt: Sanea y escapa siempre cualquier entrada de usuario o contenido din√°mico antes de insertarlo en el DOM para prevenir ataques de Cross-Site Scripting (XSS). Nunca uses innerHTML con datos no confiables.

Regla: Usa Bundlers (Webpack, Vite, Rollup): Aprende a configurar y usar herramientas para compilar y optimizar tu JavaScript.

Prompt: Configura y utiliza un bundler (ej. Webpack, Vite, Rollup) para compilar, optimizar y empaquetar los activos de JavaScript, CSS y otros recursos para producci√≥n.

Regla: Gestiona el Estado de Forma Eficiente: Elige una estrategia o librer√≠a para la gesti√≥n del estado.

Prompt: Implementa una estrategia o librer√≠a de gesti√≥n de estado (ej. Redux, Zustand, Vuex, Pinia, Context API) adecuada para la complejidad de la aplicaci√≥n, manteniendo el estado predecible y centralizado.

Regla: Entiende los Frameworks/Librer√≠as (React, Vue, Angular): Domina al menos uno a fondo.

Prompt: Desarrolla soluciones utilizando el framework o librer√≠a frontend elegido (ej. React, Vue, Angular) de acuerdo con sus mejores pr√°cticas, patrones y convenciones.

Regla: Limita las Manipulaciones Directas del DOM: Siempre que sea posible, deja que tu framework maneje el DOM por ti.

Prompt: Minimiza las manipulaciones directas del DOM. Prefiere que el framework/librer√≠a de UI gestione las actualizaciones del DOM para optimizar el rendimiento y la consistencia del estado.

Categor√≠a: Flujo de Trabajo y Herramientas

Regla: Control de Versiones (Git): Usa Git religiosamente para rastrear cambios, colaborar y revertir errores.

Prompt: Utiliza Git para el control de versiones, realizando commits at√≥micos con mensajes claros, gestionando ramas y resolviendo conflictos de fusi√≥n de manera eficiente.

Regla: Escribe Pruebas (Unitarias, de Integraci√≥n, E2E): Asegura la calidad y estabilidad de tu c√≥digo.

Prompt: Escribe pruebas unitarias, de integraci√≥n y/o E2E utilizando frameworks de testing (ej. Jest, React Testing Library, Cypress) para asegurar la funcionalidad y estabilidad del c√≥digo.

Regla: Usa un Linter y Formateador (ESLint, Prettier): Mant√©n un estilo de c√≥digo consistente y atrapa errores comunes.

Prompt: Configura y utiliza un linter (ej. ESLint) y un formateador (ej. Prettier) para aplicar autom√°ticamente un estilo de c√≥digo consistente y detectar problemas de calidad de c√≥digo y errores potenciales.

Regla: Automatiza Tareas Repetitivas: Usa scripts o herramientas para automatizar el build, la optimizaci√≥n, etc.

Prompt: Automatiza tareas repetitivas del flujo de trabajo (build, pruebas, optimizaci√≥n de activos, despliegue) utilizando scripts de NPM, Gulp, Webpack u otras herramientas de automatizaci√≥n.

Regla: Colabora Efectivamente: Comun√≠cate claramente con tu equipo y documenta tus decisiones.

Prompt: Comunica proactivamente el progreso, los desaf√≠os y las decisiones t√©cnicas al equipo. Proporciona documentaci√≥n clara para facilitar la colaboraci√≥n.

Regla: Entiende el Proceso de Build: Conoce c√≥mo tu c√≥digo se transforma de desarrollo a producci√≥n.

Prompt: Demuestra conocimiento del proceso de construcci√≥n de la aplicaci√≥n, desde el c√≥digo fuente hasta los archivos de producci√≥n optimizados, y c√≥mo se gestionan los activos.

Categor√≠a: Mentalidad y Habilidades Blandas

Regla: S√© Curioso y Sigue Aprendiendo: La tecnolog√≠a frontend evoluciona r√°pidamente.

Prompt: Demuestra una mentalidad de aprendizaje continuo, explorando nuevas tecnolog√≠as, patrones y mejores pr√°cticas del ecosistema frontend.

Regla: Pide Ayuda y Ofrece Ayuda: No temas preguntar y comparte tu conocimiento.

Prompt: Fomenta la colaboraci√≥n activa: haz preguntas cuando encuentres dificultades y comparte tu conocimiento y experiencia con otros miembros del equipo.

Regla: Entiende el Negocio/Objetivo: Comprende el prop√≥sito de lo que est√°s construyendo.

Prompt: Alinea las decisiones t√©cnicas y de dise√±o con los objetivos de negocio y el prop√≥sito general del producto, entendiendo c√≥mo tu trabajo contribuye al valor.

Regla: Prioriza la Experiencia del Usuario (UX): Dise√±a y desarrolla pensando siempre en el usuario final.

Prompt: Todas las decisiones de dise√±o y desarrollo deben centrarse en la facilidad de uso, la intuici√≥n y la satisfacci√≥n del usuario final.

Regla: S√© Paciente y Perseverante: La depuraci√≥n y la resoluci√≥n de problemas son partes integrales del desarrollo.

Prompt: Demuestra paciencia y perseverancia al enfrentar problemas complejos o al depurar errores, manteniendo un enfoque met√≥dico hasta encontrar una soluci√≥n.

Categor√≠a: Interacci√≥n con el Backend (primeras 10 de 40)

Regla: Definir un Contrato API Claro y Estable: Colabora con el equipo de backend para establecer un formato de datos, endpoints y convenciones de API bien documentados antes de escribir c√≥digo.

Prompt: Antes de implementar la l√≥gica de frontend para la interacci√≥n con el backend, asegura la existencia de un contrato API detallado y bien documentado, definido en colaboraci√≥n con el equipo de backend (ej. Swagger/OpenAPI).

Regla: Entender los Tipos de Datos del Backend: Conoce los tipos de datos que el backend enviar√° y espera (string, number, boolean, array, object, null) para evitar errores de deserializaci√≥n/serializaci√≥n.

Prompt: Al consumir o enviar datos a la API, aseg√∫rate de comprender y respetar los tipos de datos esperados por el backend para cada campo, evitando errores de tipo y conversiones inesperadas.

Regla: Manejar Errores de API de Manera Uniforme: Establece una estrategia com√∫n para capturar y mostrar errores provenientes del backend.

Prompt: Implementa una estrategia global y consistente para capturar, procesar y mostrar mensajes de error provenientes de las respuestas de la API del backend, bas√°ndose en c√≥digos de estado HTTP y estructuras de error definidas.

Regla: Validaci√≥n de Datos Tanto en Frontend como en Backend: Implementa validaciones frontend para una UX inmediata, pero nunca conf√≠es en ellas; el backend debe realizar su propia validaci√≥n.

Prompt: Aplica validaciones de entrada de datos en el frontend para feedback inmediato al usuario. Sin embargo, siempre asume que el backend realizar√° la validaci√≥n final de todos los datos antes de su procesamiento.

Regla: Comunicaci√≥n As√≠ncrona Robusta: Todas las interacciones con el backend deben ser as√≠ncronas, utilizando async/await o Promesas para evitar bloquear la UI.

Prompt: Ejecuta todas las peticiones a la API de forma as√≠ncrona utilizando async/await o Promesas. Asegura que la interfaz de usuario permanezca responsiva y no se bloquee durante las operaciones de red.

Regla: Serializaci√≥n y Deserializaci√≥n Consistente: Aseg√∫rate de que los datos se env√≠en al backend en el formato exacto que espera y de que los datos recibidos se conviertan correctamente para su uso en el frontend.

Prompt: Implementa mecanismos de serializaci√≥n (al enviar) y deserializaci√≥n (al recibir) para garantizar que los datos entre frontend y backend se conviertan correctamente al formato esperado por cada sistema.

Regla: Mapeo de Datos Claros: Si los nombres de los campos del backend no son ideales para el frontend, crea funciones de mapeo para transformar los datos en un formato m√°s amigable para la UI.

Prompt: Cuando la estructura o nombres de campos de la respuesta de la API no se alineen con la UI, crea funciones de mapeo expl√≠citas para transformar los datos del backend al formato √≥ptimo para el frontend.

Regla: Gesti√≥n de Credenciales y Autenticaci√≥n: Entiende y aplica el mecanismo de autenticaci√≥n (tokens JWT, OAuth, sesiones) de forma segura y consistente.

Prompt: Implementa el flujo de autenticaci√≥n de la aplicaci√≥n (ej. JWT, OAuth, sesiones) de forma segura, gestionando la adquisici√≥n, el almacenamiento y el env√≠o de credenciales o tokens a la API de manera consistente.

Regla: Autorizaci√≥n (Roles y Permisos): Dise√±a la UI para reflejar los permisos del usuario obtenidos del backend, ocultando o deshabilitando funcionalidades si no tiene acceso.

Prompt: Adapta din√°micamente la interfaz de usuario (ocultando elementos, deshabilitando botones, redirigiendo) bas√°ndose en los roles y permisos del usuario obtenidos del backend.

Regla: Evitar la Inferencia de Datos: No asumas c√≥mo ser√°n los datos del backend. Consulta siempre la documentaci√≥n de la API o al equipo de backend.

Prompt: Nunca asumas la estructura o el contenido de las respuestas de la API. Siempre consulta la documentaci√≥n del contrato API o comun√≠cate con el equipo de backend para confirmar las expectativas de datos.

Segunda Tanda de 50 Prompts
Categor√≠a: Interacci√≥n con el Backend (Continuaci√≥n)
Regla: Centralizar las Llamadas a la API: Crea una capa de servicio o un m√≥dulo de API para encapsular todas las llamadas HTTP, facilitando la gesti√≥n de errores, la autenticaci√≥n y el caching.
Prompt: Encapsula todas las llamadas HTTP a la API dentro de una capa de servicio o m√≥dulo centralizado. Este m√≥dulo debe manejar la configuraci√≥n base, la autenticaci√≥n, el manejo de errores y posibles estrategias de caching.
Regla: Manejo de Estados de Carga: Implementa indicadores visuales (spinners, esqueletos de carga) para informar al usuario que se est√° esperando una respuesta del backend.
Prompt: Muestra indicadores visuales de carga (ej. spinners, estados esqueleto) en la UI mientras se esperan respuestas del backend para mejorar la experiencia del usuario.
Regla: Gesti√≥n de Estados Vac√≠os/Sin Datos: Dise√±a la UI para manejar elegantemente escenarios donde el backend devuelve listas vac√≠as o no hay datos disponibles.
Prompt: Prev√© y dise√±a estados UI espec√≠ficos para cuando el backend devuelve listas vac√≠as o no hay datos disponibles, mostrando mensajes claros al usuario en lugar de interfaces rotas.
Regla: Manejo de Reintentos (Retries) en Peticiones Fallidas: Considera implementar l√≥gica para reintentar peticiones a la API en caso de fallos temporales de red o del servidor.
Prompt: Implementa una l√≥gica de reintento con un backoff exponencial para peticiones a la API que fallen debido a errores de red transitorios o del servidor.
Regla: Caching Estrat√©gico de Respuestas del Backend: Implementa cach√© en el frontend para datos que no cambian con frecuencia, reduciendo la carga del backend y mejorando la velocidad percibida.
Prompt: Utiliza t√©cnicas de cach√© en el frontend (ej. memoria, IndexedDB, librer√≠as de cach√©) para almacenar respuestas de API de datos poco cambiantes, reduciendo peticiones al backend.
Regla: Uso de Interceptores (Axios, Fetch API): Configura interceptores para a√±adir headers de autenticaci√≥n, registrar errores o transformar peticiones/respuestas globalmente.
Prompt: Configura interceptores HTTP (para Fetch API o librer√≠as como Axios) para gestionar tareas transversales como a√±adir tokens de autenticaci√≥n, registrar errores o transformar datos de forma global.
Regla: Optimizaci√≥n de Cargas √ötiles (Payloads): Solicita al backend solo los datos que realmente necesitas para la vista actual, evitando sobrecargar la red.
Prompt: Al construir peticiones a la API, solicita solo los campos o datos estrictamente necesarios para la vista actual, optimizando el tama√±o de la carga √∫til (payload).
Regla: Paginaci√≥n y Filtrado del Lado del Servidor: Implementa paginaci√≥n, filtrado y ordenaci√≥n enviando par√°metros al backend, para no cargar datos excesivos en el frontend.
Prompt: Implementa la paginaci√≥n, filtrado y ordenaci√≥n de datos enviando los par√°metros correspondientes al backend, en lugar de intentar procesar grandes conjuntos de datos en el frontend.
Regla: Manejo de Concurrencia (Race Conditions): Prev√© y maneja escenarios donde m√∫ltiples peticiones a la API puedan sobrescribir datos o crear estados inconsistentes en la UI.
Prompt: Implementa estrategias para prevenir o manejar condiciones de carrera (race conditions) resultantes de m√∫ltiples peticiones as√≠ncronas, asegurando la consistencia del estado de la UI.
Regla: Limpiar Datos Antes de Enviar al Backend: Aseg√∫rate de que los datos enviados desde formularios o la UI est√©n limpios, formateados correctamente y sin informaci√≥n superflua.
Prompt: Antes de enviar datos al backend, aseg√∫rate de que est√©n limpios, correctamente formateados y desprovistos de cualquier informaci√≥n innecesaria o sensible desde la UI.
Regla: Uso de Herramientas de Desarrollo (Postman, Insomnia, Swagger UI): Familiar√≠zate con estas herramientas para probar y entender la API del backend de forma independiente.
Prompt: Demuestra el uso de herramientas como Postman, Insomnia o la interfaz de Swagger UI para probar y comprender la funcionalidad de la API del backend de forma independiente.
Regla: Mockear la API del Backend: Crea "mocks" (datos falsos) o un servidor de desarrollo con una API simulada para desarrollar el frontend en paralelo antes de que el backend est√© listo.
Prompt: Crea mocks de la API del backend o utiliza un servidor de desarrollo con una API simulada para permitir el desarrollo y las pruebas del frontend en paralelo al desarrollo del backend.
Regla: Colaboraci√≥n Continua con el Equipo de Backend: Mant√©n una comunicaci√≥n fluida para resolver dudas, discutir cambios en la API y coordinar el desarrollo.
Prompt: Mant√©n una comunicaci√≥n bidireccional constante y fluida con el equipo de backend para resolver dudas, coordinar cambios en la API y asegurar una integraci√≥n armoniosa.
Regla: Documentaci√≥n Frontend del Uso de la API: Documenta c√≥mo el frontend consume cada endpoint, los datos que espera y los que env√≠a.
Prompt: Crea documentaci√≥n espec√≠fica en el frontend sobre c√≥mo se consume cada endpoint de la API, incluyendo el formato de la petici√≥n, la respuesta esperada y el manejo de errores.
Regla: Feedback Claro al Backend sobre Inconsistencias: Reporta proactivamente cualquier inconsistencia, error o ambig√ºedad en la API del backend.
Prompt: Reporta de manera proactiva y constructiva cualquier inconsistencia, error, ambig√ºedad o mejora sugerida en la API del backend al equipo correspondiente.
Regla: Entender el Versionado de la API (API Versioning): Si el backend versiona su API, tenlo en cuenta en tu implementaci√≥n.
Prompt: Implementa el consumo de la API considerando su estrategia de versionado (ej. /v1/users, /v2/users), asegurando compatibilidad con las versiones objetivo.
Regla: Uso de Entornos (Development, Staging, Production): Configura el frontend para conectarse a diferentes entornos de backend (dev, test, prod) seg√∫n sea necesario.
Prompt: Configura el frontend para que se conecte a diferentes entornos de backend (desarrollo, staging, producci√≥n) utilizando variables de entorno o configuraciones espec√≠ficas para cada entorno.
Regla: Env√≠o de Logs y Errores al Backend: Implementa un sistema para enviar logs y errores cr√≠ticos del frontend al backend para una depuraci√≥n centralizada.
Prompt: Implementa un mecanismo para enviar logs de errores cr√≠ticos y eventos relevantes del frontend a un servicio de logging centralizado, a menudo gestionado por el backend.
Regla: Optimizaci√≥n de la Comunicaci√≥n HTTP/2 o WebSockets: Considera el uso de HTTP/2 para multiplexado o WebSockets para comunicaci√≥n en tiempo real si la aplicaci√≥n lo requiere.
Prompt: Eval√∫a y, si es necesario, implementa protocolos de comunicaci√≥n avanzados como HTTP/2 para peticiones multiplexadas o WebSockets para comunicaci√≥n en tiempo real.
Regla: No Exponer L√≥gica Sensible del Backend: Aseg√∫rate de que ninguna l√≥gica cr√≠tica de negocio o credencial sensible del backend est√© presente o sea deducible desde el frontend.
Prompt: Garantiza que el frontend no contenga, revele o permita la deducci√≥n de l√≥gica de negocio sensible, credenciales de backend o claves de API que deber√≠an residir exclusivamente en el servidor.
Regla: Dise√±o Desacoplado del Backend: La UI no debe estar r√≠gidamente acoplada a una estructura de backend espec√≠fica; debe ser lo suficientemente flexible para adaptarse a cambios.
Prompt: Dise√±a la interfaz de usuario de manera desacoplada de la implementaci√≥n espec√≠fica del backend, permitiendo flexibilidad para cambios en la API sin requerir una reescritura significativa del frontend.
Regla: Manejar Respuestas Inesperadas del Backend: Programa de forma defensiva para situaciones donde el backend devuelva datos en un formato inesperado o con campos faltantes.
Prompt: Escribe c√≥digo defensivo para manejar respuestas inesperadas de la API, como estructuras de datos incorrectas, campos nulos o faltantes, o formatos de datos no conformes.
Regla: Uso de Schemas o Tipado Fuerte (TypeScript): Si usas TypeScript, define interfaces o tipos para las respuestas de la API para garantizar la consistencia.
Prompt: Si utilizas TypeScript, define interfaces o tipos de datos claros y precisos para las estructuras de respuesta esperadas de la API, garantizando la consistencia y la seguridad de tipos.
Regla: Considerar la Escalabilidad de la API: Dise√±a las llamadas a la API pensando en c√≥mo afectar√°n el rendimiento si el volumen de datos o usuarios crece.
Prompt: Al dise√±ar interacciones con la API, considera c√≥mo escalar√° el volumen de peticiones y datos a medida que la aplicaci√≥n crezca, planificando la eficiencia y el uso de recursos.
Regla: Gesti√≥n de Sesiones y Expiraci√≥n: Entiende y maneja la expiraci√≥n de sesiones/tokens, redirigiendo al usuario a la autenticaci√≥n cuando sea necesario.
Prompt: Implementa el manejo de la expiraci√≥n de tokens de sesi√≥n o JWT, incluyendo la l√≥gica para renovarlos o redirigir al usuario a la pantalla de inicio de sesi√≥n cuando sea necesario.
Regla: Limpieza de Datos al Desmontar Componentes: Aseg√∫rate de cancelar peticiones API pendientes o limpiar el estado relacionado con el backend cuando un componente se desmonta para evitar fugas de memoria o errores.
Prompt: Al desmontar componentes, cancela cualquier petici√≥n API pendiente y limpia los estados o suscripciones relacionados con el backend para prevenir fugas de memoria y errores.
Regla: Manejo de Conectividad sin Conexi√≥n (Offline First/PWA): Si es un requisito, implementa Service Workers y estrategias de almacenamiento offline para una experiencia robusta sin conexi√≥n.
Prompt: Si la aplicaci√≥n requiere funcionamiento offline, implementa Service Workers y estrategias de almacenamiento en cach√© para proporcionar una experiencia de usuario robusta sin conexi√≥n a la red.
Regla: Feedback Visual en Tiempo Real para Acciones del Usuario: Confirma r√°pidamente las acciones del usuario en la UI (ej. "Guardando...", "Eliminado") incluso antes de recibir la confirmaci√≥n del backend.
Prompt: Proporciona feedback visual inmediato en la UI para las acciones del usuario (ej. "Guardando...", "Actualizado"), incluso antes de que la respuesta del backend se reciba.
Regla: Planificar para Cambios en la API: Asume que la API evolucionar√°. Dise√±a tu c√≥digo para que sea flexible ante adiciones o peque√±os cambios en los endpoints o estructuras de datos.
Prompt: Dise√±a el c√≥digo de interacci√≥n con la API con flexibilidad, anticipando que la API evolucionar√° y permitiendo la adaptaci√≥n a cambios o adiciones en los endpoints y estructuras de datos.
Regla: Probar la Integraci√≥n Temprano y Frecuentemente: No esperes a que todo el frontend y el backend est√©n listos. Realiza pruebas de integraci√≥n incrementalmente para identificar problemas a tiempo.
Prompt: Realiza pruebas de integraci√≥n entre el frontend y el backend de forma temprana y continua en el ciclo de desarrollo para detectar y resolver problemas de compatibilidad r√°pidamente.
Categor√≠a: Seguridad Impecable (primeras 20 de 40)
Regla: Nunca Insertes HTML de Fuentes No Confiables Directamente en el DOM: Siempre sanea o escapa cualquier contenido din√°mico que provenga de usuarios o APIs antes de mostrarlo.
Prompt: Proh√≠be la inserci√≥n directa de HTML proveniente de fuentes no confiables (ej. entrada de usuario, APIs externas) en el DOM. Siempre sanea o escapa el contenido antes de renderizarlo.
Regla: Utiliza API de Saneamiento Seguras: Emplea librer√≠as o frameworks que proporcionen m√©todos seguros para escapar contenido.
Prompt: Utiliza APIs y librer√≠as de saneamiento de contenido (ej. DOMPurify) que escapen autom√°ticamente los caracteres peligrosos, o las funcionalidades nativas de seguridad de los frameworks (ej. textContent en lugar de innerHTML).
Regla: Codifica Salidas Espec√≠ficas al Contexto: Escapa los caracteres especiales seg√∫n el contexto (HTML, URL, JavaScript) para evitar que el c√≥digo inyectado sea interpretado.
Prompt: Codifica o escapa los caracteres especiales de las salidas de datos din√°micos seg√∫n el contexto en el que se van a insertar (HTML, URL, JavaScript) para prevenir inyecciones.
Regla: Configura una Pol√≠tica de Seguridad de Contenido (CSP) Robusta: Define qu√© recursos (scripts, estilos, im√°genes) pueden ser cargados por la p√°gina y desde d√≥nde, mitigando ataques XSS.
Prompt: Implementa una Pol√≠tica de Seguridad de Contenido (CSP) estricta a trav√©s de cabeceras HTTP o metaetiquetas, definiendo expl√≠citamente las fuentes permitidas para scripts, estilos y otros recursos.
Regla: Evita eval(), setTimeout(string), setInterval(string): Estas funciones pueden ejecutar c√≥digo arbitrario y son vectores comunes para XSS.
Prompt: Proh√≠be el uso de eval(), setTimeout() con cadenas de texto y setInterval() con cadenas de texto, ya que pueden ejecutar c√≥digo arbitrario y son vectores de ataque.
Regla: No Uses javascript: URLs en Atributos href o src:** Son una fuente conocida de inyecci√≥n de c√≥digo malicioso.
Prompt: No permitas el uso de URLs que comiencen con javascript: en atributos como href o src, ya que pueden ser utilizados para ejecutar c√≥digo malicioso.
Regla: Utiliza Tokens Anti-CSRF Generados por el Backend: El backend debe emitir un token √∫nico que el frontend incluya en cada solicitud que modifique el estado.
Prompt: Integra tokens anti-CSRF generados por el backend en todas las peticiones que modifiquen el estado (POST, PUT, DELETE), asegurando que el token se incluya y valide en cada solicitud.
Regla: Env√≠a Tokens CSRF en un Encabezado Personalizado (Header): Evita enviarlos en cookies que el navegador pueda adjuntar autom√°ticamente a solicitudes cross-site.
Prompt: Env√≠a los tokens CSRF en encabezados HTTP personalizados (ej. X-CSRF-Token) en lugar de en cookies, para evitar que sean enviados autom√°ticamente en solicitudes cross-site.
Regla: Aseg√∫rate de que las Cookies de Sesi√≥n Tengan el Atributo SameSite=Lax o Strict:** Esto limita el env√≠o de cookies en solicitudes cross-site, reduciendo el riesgo de CSRF.
Prompt: Asegura que todas las cookies de sesi√≥n y autenticaci√≥n tengan el atributo SameSite configurado como Lax o Strict para mitigar ataques CSRF.
Regla: Para Operaciones Sensibles, Requiere Re-autenticaci√≥n o Confirmaci√≥n: Un paso adicional de seguridad para acciones cr√≠ticas.
Prompt: Para operaciones de alta sensibilidad (ej. cambio de contrase√±a, eliminaci√≥n de cuenta), implementa un paso adicional de re-autenticaci√≥n o confirmaci√≥n expl√≠cita del usuario.
Regla: Nunca Almacenes Credenciales Sensibles (Contrase√±as, Secretos) en el Frontend:** Las contrase√±as deben ser enviadas al backend (preferiblemente cifradas/hasheadas en tr√°nsito) y nunca guardadas localmente.
Prompt: Proh√≠be el almacenamiento de credenciales sensibles (ej. contrase√±as, claves API) en el frontend, incluyendo localStorage, sessionStorage o cookies no HttpOnly.
Regla: Maneja Tokens de Autenticaci√≥n de Forma Segura: Almacena tokens JWT o de sesi√≥n en localStorage o sessionStorage solo si entiendes los riesgos. Las Cookies HttpOnly son m√°s seguras contra XSS.
Prompt: Gestiona los tokens de autenticaci√≥n de forma segura. Prioriza el uso de cookies HttpOnly para tokens de sesi√≥n o JWT, o implementa protecciones adicionales si se almacenan en localStorage.
Regla: Usa Tokens de Corta Duraci√≥n con Refresh Tokens: Si usas JWT, implementa tokens de acceso de corta duraci√≥n y un mecanismo seguro para renovarlos con un refresh token.
Prompt: Cuando se utilicen tokens JWT, implementa tokens de acceso de corta duraci√≥n y un mecanismo seguro de "refresh tokens" para renovarlos, limitando la ventana de exposici√≥n en caso de compromiso.
Regla: Protege las Rutas Sensibles del Frontend: Implementa guardias de ruta (route guards) para asegurar que solo los usuarios autenticados y autorizados puedan acceder a ciertas secciones de la aplicaci√≥n.
Prompt: Implementa guardias de ruta (route guards) en el frontend para proteger las rutas sensibles, permitiendo el acceso solo a usuarios autenticados y con los roles/permisos necesarios.
Regla: Siempre Confirma la Autorizaci√≥n del Lado del Servidor: El frontend puede ocultar opciones, pero la validaci√≥n final de si un usuario puede realizar una acci√≥n siempre debe ser del backend.
Prompt: Aunque el frontend pueda ajustar la UI seg√∫n la autorizaci√≥n, siempre asume que la validaci√≥n final y decisiva de la autorizaci√≥n de un usuario para realizar una acci√≥n se realizar√° en el backend.
Regla: No Reveles Informaci√≥n Sensible en el Frontend: Evita mostrar IDs internos de base de datos, URLs de API sensibles o l√≥gicas de negocio cr√≠ticas en el c√≥digo fuente o en las respuestas de la API.
Prompt: Evita exponer informaci√≥n sensible (ej. IDs internos de BD, URLs de API confidenciales, l√≥gica de negocio cr√≠tica) en el c√≥digo fuente del frontend, el DOM o las respuestas de la API.
Regla: Implementa Logout Seguro: Asegura que, al cerrar sesi√≥n, se invaliden los tokens del frontend y, si es posible, tambi√©n en el backend.
Prompt: Implementa un proceso de cierre de sesi√≥n seguro que invalide el token de autenticaci√≥n en el frontend y, preferiblemente, tambi√©n en el backend, y elimine cualquier dato de sesi√≥n local.
Regla: Configura HTTPS para Toda la Comunicaci√≥n: Todas las comunicaciones entre el frontend y el backend deben ser cifradas usando TLS/SSL para prevenir ataques Man-in-the-Middle.
Prompt: Asegura que toda la comunicaci√≥n entre el frontend y el backend se realice exclusivamente a trav√©s de HTTPS/TLS para cifrar los datos en tr√°nsito y prevenir ataques Man-in-the-Middle.
Regla: Habilita HTTP Strict Transport Security (HSTS): Fuerza a los navegadores a usar HTTPS para futuras conexiones, incluso si el usuario intenta acceder v√≠a HTTP.
Prompt: Configura la cabecera HTTP Strict-Transport-Security (HSTS) para forzar al navegador a utilizar siempre HTTPS para futuras conexiones a tu dominio.
Regla: Configura los Headers X-Content-Type-Options: nosniff:** Previene que el navegador "adivine" el tipo de MIME del contenido, evitando ataques de inyecci√≥n de scripts.
* Prompt: Establece la cabecera HTTP X-Content-Type-Options a nosniff para evitar el "MIME-sniffing" del navegador, previniendo la ejecuci√≥n de contenido malicioso como script.

Categor√≠a: Seguridad Impecable (Continuaci√≥n)
Regla: Configura los Headers X-Frame-Options: DENY o SAMEORIGIN:** Protege contra ataques de Clickjacking, evitando que tu p√°gina se incruste en un <iframe> de otro dominio.
* Prompt: Configura la cabecera HTTP X-Frame-Options a DENY o SAMEORIGIN para proteger la aplicaci√≥n contra ataques de Clickjacking.
Regla: Configura el Header Referrer-Policy:** Controla la cantidad de informaci√≥n del Referer que se env√≠a con las solicitudes.
* Prompt: Establece una Referrer-Policy adecuada (ej. no-referrer, same-origin) para controlar la informaci√≥n del Referer enviada en las solicitudes HTTP.
Regla: Controla el Access-Control-Allow-Origin (CORS): Define expl√≠citamente qu√© or√≠genes pueden acceder a tus recursos, evitando accesos no autorizados.
* Prompt: Configura cuidadosamente el encabezado Access-Control-Allow-Origin en el backend para permitir el acceso CORS solo desde los dominios autorizados del frontend.
Regla: Valida Todas las Entradas del Usuario en el Frontend:** Si bien el backend validar√°, el frontend debe realizar validaciones b√°sicas para dar feedback instant√°neo y mejorar la UX.
* Prompt: Implementa validaciones frontend exhaustivas para todas las entradas de usuario, proporcionando feedback instant√°neo y guiando al usuario hacia datos v√°lidos.
Regla: Nunca Uses Datos de Entrada del Usuario Directamente en Consultas SQL o L√≥gicas Cr√≠ticas:** Esto es m√°s del backend, pero el frontend no debe construir consultas con entradas directas.
* Prompt: El frontend nunca debe utilizar directamente la entrada del usuario para construir consultas de base de datos o l√≥gica cr√≠tica; toda la validaci√≥n y construcci√≥n de consultas debe ser manejada por el backend.
Regla: Escapa o Sanea Contenido de Terceros o APIs Externas:** Trata el contenido de cualquier fuente externa con el mismo nivel de desconfianza que el contenido del usuario.
* Prompt: Aplica el mismo rigor de saneamiento y escape al contenido proveniente de servicios de terceros o APIs externas que a la entrada directa del usuario.
Regla: Audita las Dependencias de Terceros Regularmente:** Usa herramientas como npm audit o Snyk para identificar vulnerabilidades en tus librer√≠as y frameworks.
* Prompt: Realiza auditor√≠as de seguridad regulares de todas las dependencias de terceros (ej. npm audit, Snyk) para identificar y remediar vulnerabilidades conocidas.
Regla: Mant√©n tus Dependencias Actualizadas:** Las versiones m√°s recientes a menudo contienen parches de seguridad importantes.
* Prompt: Mant√©n las librer√≠as, frameworks y dependencias del proyecto actualizadas a sus √∫ltimas versiones estables para beneficiarse de parches de seguridad y mejoras de rendimiento.
Regla: Revisa el C√≥digo Fuente de las Librer√≠as Cr√≠ticas (si es posible):** Especialmente para librer√≠as de autenticaci√≥n o seguridad.
* Prompt: Para librer√≠as cr√≠ticas, especialmente las relacionadas con seguridad o autenticaci√≥n, realiza revisiones de su c√≥digo fuente si es posible o conf√≠a en fuentes auditadas.
Regla: Minimiza la Superficie de Ataque:** Incluye solo el c√≥digo y las librer√≠as que realmente necesitas, reduciendo posibles puntos de vulnerabilidad.
* Prompt: Minimiza la superficie de ataque del frontend incluyendo solo el c√≥digo y las dependencias estrictamente necesarias, eliminando funcionalidades no utilizadas.
Regla: Elimina C√≥digo Muerto y Comentarios Sensibles:** No dejes informaci√≥n que pueda ser √∫til para un atacante en el c√≥digo de producci√≥n.
* Prompt: Elimina todo el c√≥digo muerto, comentarios sensibles o informaci√≥n de depuraci√≥n antes de desplegar la aplicaci√≥n a producci√≥n.
Regla: Principio de M√≠nimo Privilegio:** La aplicaci√≥n frontend solo debe tener los permisos y acceder a los recursos estrictamente necesarios.
* Prompt: Dise√±a la aplicaci√≥n con el principio de m√≠nimo privilegio en mente: el frontend solo debe tener los permisos y acceder a los recursos estrictamente necesarios para su funcionamiento.
Regla: Usa Content Security Policy (CSP) en Modo de Reporte Primero:** Despli√©gala inicialmente en modo solo de reporte para identificar infracciones sin bloquear el sitio.
* Prompt: Antes de aplicar una CSP en modo de imposici√≥n, despli√©gala en modo de "solo reporte" (Content-Security-Policy-Report-Only) para monitorear violaciones sin bloquear el contenido leg√≠timo.
Regla: Educaci√≥n Continua en Seguridad:** Mantente actualizado sobre las √∫ltimas vulnerabilidades, ataques y mejores pr√°cticas en seguridad frontend.
* Prompt: Mantente continuamente informado sobre las √∫ltimas amenazas de seguridad frontend, vulnerabilidades, ataques comunes y mejores pr√°cticas de defensa.
Regla: Realiza Pruebas de Penetraci√≥n Regularmente:** Contrata a expertos para que intenten encontrar fallas de seguridad en tu aplicaci√≥n.
* Prompt: En fases avanzadas del proyecto, recomienda y participa en pruebas de penetraci√≥n profesionales para identificar vulnerabilidades de seguridad que las pruebas automatizadas podr√≠an pasar por alto.
Regla: No Conf√≠es en la Ofuscaci√≥n del C√≥digo:** La ofuscaci√≥n puede dificultar un poco la ingenier√≠a inversa, pero no es una medida de seguridad efectiva.
* Prompt: No consideres la ofuscaci√≥n del c√≥digo JavaScript como una medida de seguridad robusta. Util√≠zala solo para dificultar la ingenier√≠a inversa, no para proteger l√≥gica sensible.
Regla: Deshabilita las Herramientas de Desarrollo en Producci√≥n:** Aunque es dif√≠cil, minimiza la informaci√≥n que puedan obtener los atacantes.
* Prompt: En el entorno de producci√≥n, minimiza la informaci√≥n disponible a trav√©s de las herramientas de desarrollo del navegador, deshabilitando sourcemaps o minimizando logs sensibles.
Regla: Maneja los Mensajes de Error con Cuidado:** Evita dar demasiada informaci√≥n sobre la infraestructura o la base de datos en los mensajes de error p√∫blicos.
* Prompt: Al mostrar mensajes de error al usuario, evita revelar detalles t√©cnicos sensibles sobre la infraestructura del servidor, bases de datos o l√≥gica interna.
Regla: No Hardcod√©es IDs de Usuarios, Claves API o Informaci√≥n Sensible:** Estas deben ser manejadas por el backend y enviadas de forma segura cuando sea necesario.
* Prompt: Nunca codifiques (hardcode) IDs de usuario, claves de API, secretos o cualquier otra informaci√≥n sensible directamente en el c√≥digo del frontend.
Regla: Desarrolla con un Modelo de Amenazas en Mente:** Piensa como un atacante. ¬øC√≥mo intentar√≠as romper tu propia aplicaci√≥n?
* Prompt: Al desarrollar, adopta una mentalidad de modelado de amenazas: anticipa c√≥mo un atacante podr√≠a intentar explotar vulnerabilidades en la aplicaci√≥n.
Categor√≠a: Principios de Arquitectura y Dise√±o S√≥lido (Tus reglas adicionales)
Regla: Principio de Responsabilidad √önica (SRP): Cada clase/funci√≥n debe tener una sola raz√≥n para cambiar.
* Prompt: Dise√±a funciones, clases y componentes de modo que cada uno tenga una √∫nica responsabilidad bien definida y, por lo tanto, solo una raz√≥n para cambiar.
Regla: Inversi√≥n de Dependencias: Depender de abstracciones, no de implementaciones concretas.
* Prompt: Al dise√±ar la arquitectura, haz que los m√≥dulos de alto nivel no dependan de los de bajo nivel. Ambos deben depender de abstracciones (interfaces o tipos), no de implementaciones concretas.
Regla: Separaci√≥n de Concerns: UI, l√≥gica de negocio y datos deben estar claramente separados.
* Prompt: Estructura el c√≥digo de manera que las preocupaciones de la interfaz de usuario, la l√≥gica de negocio y la gesti√≥n de datos est√©n claramente separadas y encapsuladas.
Regla: Principio de Composici√≥n sobre Herencia: Favorecer composici√≥n para mayor flexibilidad.
* Prompt: Prefiere la composici√≥n de peque√±os componentes o funciones para construir funcionalidades complejas, en lugar de depender excesivamente de la herencia de clases.
Regla: Arquitectura por Capas: Estructura clara entre presentaci√≥n, l√≥gica y datos.
* Prompt: Implementa una arquitectura por capas donde la presentaci√≥n, la l√≥gica de aplicaci√≥n/negocio y la capa de acceso a datos est√©n claramente definidas y separadas.
Regla: Principio KISS (Keep It Simple, Stupid): Prefiere soluciones sencillas a las complejas.
* Prompt: Busca siempre la soluci√≥n m√°s simple y directa a un problema, evitando la complejidad innecesaria incluso si otras soluciones parecen m√°s "elegantes".
Categor√≠a: Pr√°cticas de Desarrollo Moderno y Experiencia de Usuario (Tus reglas adicionales)
Regla: TypeScript First: Tipado est√°tico para prevenir errores en tiempo de compilaci√≥n.
* Prompt: Desarrolla la aplicaci√≥n utilizando TypeScript desde el inicio, definiendo tipos expl√≠citos para variables, funciones y estructuras de datos para prevenir errores en tiempo de compilaci√≥n.
Regla: Progressive Enhancement: La aplicaci√≥n debe funcionar sin JavaScript como base.
* Prompt: Dise√±a la aplicaci√≥n siguiendo el principio de "Progressive Enhancement", asegurando una experiencia funcional b√°sica incluso si JavaScript est√° deshabilitado o no se carga.
Regla: Mobile First: Dise√±ar primero para m√≥vil, luego escalar a desktop.
* Prompt: Adopta una estrategia de dise√±o "Mobile First", desarrollando y probando la interfaz de usuario primero en dispositivos m√≥viles y luego escalando para pantallas m√°s grandes.
Regla: Performance Budget: Establecer l√≠mites de tama√±o de bundle y tiempo de carga.
* Prompt: Establece y adhiere a un "Performance Budget" (presupuesto de rendimiento) claro para m√©tricas como el tama√±o del bundle, el tiempo de carga y la interactividad.
Regla: Atomic Design: Componentes organizados en √°tomos, mol√©culas, organismos, templates y p√°ginas.
* Prompt: Organiza los componentes de la interfaz de usuario utilizando la metodolog√≠a de Atomic Design (√°tomos, mol√©culas, organismos, plantillas, p√°ginas) para promover la consistencia y reutilizaci√≥n.
Categor√≠a: Flujo de Trabajo, Calidad y Mantenimiento (Tus reglas adicionales)
Regla: CI/CD Pipeline: Integraci√≥n y despliegue continuo automatizado.
* Prompt: Configura e implementa una pipeline de CI/CD (Integraci√≥n Continua/Despliegue Continuo) para automatizar la construcci√≥n, prueba y despliegue del frontend.
Regla: Environment Parity: Desarrollo, staging y producci√≥n deben ser id√©nticos.
* Prompt: Asegura que los entornos de desarrollo, staging y producci√≥n sean lo m√°s parecidos posible en t√©rminos de configuraci√≥n, dependencias y datos para evitar problemas de "funciona en mi m√°quina".
Regla: Feature Flags: Despliegue de funcionalidades controlado y reversible.
* Prompt: Implementa "Feature Flags" (interruptores de caracter√≠sticas) para habilitar o deshabilitar funcionalidades de forma remota, permitiendo lanzamientos controlados y reversiones r√°pidas.
Regla: Code Review Obligatorio: Todo c√≥digo debe ser revisado por al menos un peer.
* Prompt: Haz que la revisi√≥n de c√≥digo por al menos un compa√±ero sea un requisito obligatorio antes de fusionar cualquier cambio en la rama principal.
Regla: Documentaci√≥n Viva: README, CHANGELOG y documentaci√≥n t√©cnica siempre actualizada.
* Prompt: Mant√©n la documentaci√≥n del proyecto (README, CHANGELOG, documentaci√≥n t√©cnica interna, gu√≠as de contribuci√≥n) siempre actualizada y alineada con el c√≥digo.
Categor√≠a: Interacci√≥n Backend Espec√≠fica (Tus reglas adicionales)
Regla: Control de Transacciones (Backend): Garantizar la integridad de los datos en operaciones de base de datos complejas.
* Prompt: Si el frontend inicia operaciones que implican transacciones complejas en el backend, el frontend debe ser consciente de la necesidad de integridad de datos y c√≥mo el backend maneja las transacciones.
Regla: Idempotencia de APIs (Backend): Las APIs deben ser idempotentes cuando sea apropiado.
* Prompt: El frontend debe saber cu√°ndo las APIs del backend son idempotentes (es decir, que una petici√≥n repetida tiene el mismo efecto que la primera) para gestionar reintentos de forma segura y sin efectos secundarios.

Categor√≠a Sugerida: Experiencia de Usuario Avanzada y Resiliencia del Frontend
Esta categor√≠a se enfocar√≠a en c√≥mo el frontend no solo reacciona, sino que proactivamente gestiona la interacci√≥n con el usuario, incluso cuando las cosas no salen seg√∫n lo planeado (m√°s all√° de los errores de API).
Regla: Dise√±o de Estados Vac√≠os y de Error Informativos: No solo "manejar" errores, sino proporcionar mensajes claros, contextualmente relevantes y, si es posible, acciones sugeridas al usuario.
Prompt: Para cada posible estado de datos vac√≠o (ej. lista de productos vac√≠a, resultados de b√∫squeda nulos) o error (ej. formulario inv√°lido, recurso no encontrado), dise√±a una interfaz que proporcione informaci√≥n clara, √∫til y, si aplica, acciones para que el usuario pueda avanzar.
Regla: Retroalimentaci√≥n Contextual y No Intrusiva: Proporcionar feedback al usuario de manera que no interrumpa su flujo, usando notificaciones no modales cuando sea posible.
Prompt: Implementa un sistema de notificaciones o feedback que sea contextual y no bloqueante (ej. toasts, banners temporales) para informar al usuario sobre el √©xito de las operaciones o errores menores, evitando interrupciones innecesarias.
Regla: Gesti√≥n del Historial de Navegaci√≥n y URLs Amigables: Asegurar que la navegaci√≥n sea consistente con el historial del navegador y que las URLs sean significativas para el usuario y el SEO.
Prompt: Gestiona el historial de navegaci√≥n de forma consistente, permitiendo que el bot√≥n "atr√°s" del navegador funcione como se espera. Utiliza URLs limpias y sem√°nticas que reflejen el estado actual de la aplicaci√≥n.
Regla: Manejo de Entradas del Usuario (Input Management) Inteligente: Optimizar la experiencia de entrada de datos, incluyendo autofoco, formato autom√°tico, m√°scaras y sugerencias.
Prompt: Mejora la experiencia de entrada de datos del usuario implementando funciones como autofoco en el campo relevante, formato autom√°tico de datos (ej. n√∫meros de tel√©fono), sugerencias de autocompletado y m√°scaras de entrada.
Regla: Pre-carga y Precaching (User Anticipation): Anticipar las necesidades del usuario cargando recursos o datos antes de que sean expl√≠citamente solicitados, mejorando la fluidez.
Prompt: Identifica puntos clave en la interacci√≥n del usuario donde se pueda precargar o hacer precaching de recursos (ej. im√°genes de la siguiente p√°gina, datos de un m√≥dulo probable) para mejorar la velocidad percibida y la fluidez de la navegaci√≥n.
Regla: Consideraci√≥n de la Latencia (Optimistic UI): Dise√±ar interfaces que respondan instant√°neamente a las acciones del usuario, actualizando la UI de forma "optimista" antes de la confirmaci√≥n del backend.
Prompt: Implementa patrones de "Optimistic UI" donde sea apropiado, actualizando la interfaz de usuario inmediatamente despu√©s de una acci√≥n del usuario y revirtiendo solo si el backend reporta un error.
Regla: Microinteracciones y Animaciones con Prop√≥sito: Utilizar animaciones y microinteracciones para guiar la atenci√≥n del usuario, proporcionar feedback o mejorar la percepci√≥n de rendimiento, sin ser intrusivo.
Prompt: Incorpora microinteracciones y animaciones sutiles y con prop√≥sito para guiar la atenci√≥n del usuario, proporcionar feedback visual sobre las acciones o mejorar la percepci√≥n de la velocidad.

Categor√≠a: Componentes de Seguridad Reutilizables
Regla #159: Sanitizaci√≥n de Datos de Entrada (Anti-XSS) üü¢
Prompt: "Crea un componente de React llamado SecureInput.tsx usando TypeScript. Este componente debe ser un input o textarea que, al recibir cualquier dato del usuario, lo sanitice de forma autom√°tica y en tiempo real para prevenir ataques de Cross-Site Scripting (XSS). La l√≥gica de sanitizaci√≥n debe usar la biblioteca dompurify para eliminar cualquier script o etiqueta maliciosa. Incluye los comandos de instalaci√≥n de la biblioteca y sus tipos de TypeScript. El componente debe tener un estado interno para el valor sanitizado y un onChange que actualice este estado y, opcionalmente, pase el valor sanitizado a un padre. Proporciona ejemplos de uso, uno donde se muestre el valor crudo (sin sanitizar) y otro donde se muestre el valor sanitizado para ilustrar la diferencia. A√±ade comentarios detallados en el c√≥digo para explicar el proceso de sanitizaci√≥n."

Regla #160: Uso de HTTPS (Comunicaci√≥n Segura) üü°
Prompt: "Describe y proporciona las instrucciones paso a paso para configurar un servidor de desarrollo de React con Vite para que use HTTPS en lugar de HTTP. El objetivo es simular un entorno de producci√≥n seguro. Explica c√≥mo generar certificados SSL autofirmados usando la terminal, c√≥mo modificar el archivo vite.config.ts para habilitar el servidor HTTPS y c√≥mo configurar las opciones de certificado. Incluye un ejemplo completo de vite.config.ts con comentarios que expliquen cada configuraci√≥n. Al final, proporciona el comando para ejecutar el servidor de desarrollo en modo seguro."

Regla #161: Implementaci√≥n de CSP (Content Security Policy) üü¢
Prompt: "Genera una pol√≠tica de seguridad de contenido (CSP) exhaustiva para una aplicaci√≥n de React que se carga desde una CDN. La pol√≠tica debe ser lo m√°s estricta posible, permitiendo solo recursos de confianza. Especifica las directivas para: script-src (solo desde el propio dominio y la CDN), style-src (dominio propio y Google Fonts), img-src (dominio propio y un servicio de almacenamiento como Cloudinary), font-src (Google Fonts), y connect-src (solo para las APIs de tu backend y una API de pagos de terceros). Proporciona el c√≥digo completo del meta tag HTML y explica brevemente la funci√≥n de cada directiva. Adem√°s, incluye la directiva report-uri para enviar informes de violaciones a un servicio de monitoreo."

Regla #162: Protecci√≥n contra Clickjacking üü¢
Prompt: "Explica en detalle qu√© es un ataque de clickjacking y c√≥mo los atacantes lo usan para enga√±ar a los usuarios. Luego, proporciona las dos mejores pr√°cticas para mitigar este riesgo. La primera, usando la cabecera HTTP X-Frame-Options con el valor deny o SAMEORIGIN. La segunda, usando la directiva frame-ancestors en la pol√≠tica de seguridad de contenido (CSP). Muestra ejemplos de c√≥digo para ambos m√©todos y explica por qu√© la directiva frame-ancestors es la opci√≥n m√°s moderna y flexible."

Regla #163: Manejo Seguro de Cookies y Almacenamiento üü°
Prompt: "Describe la forma m√°s segura de manejar tokens de sesi√≥n o de autenticaci√≥n en el frontend de una tienda online. Explica las diferencias entre almacenar un token en localStorage y en una cookie. Luego, argumenta por qu√© las cookies con los atributos HttpOnly y Secure son la opci√≥n preferida para datos sensibles. Detalla la funci√≥n de estos dos atributos y a√±ade la explicaci√≥n del atributo SameSite y por qu√© es crucial para prevenir ataques CSRF. Proporciona un pseudoc√≥digo que ilustre c√≥mo el backend deber√≠a establecer una cookie de autenticaci√≥n segura."

Regla #164: Validaci√≥n de Datos en el Frontend con Esquemas üü¢
Prompt: "Crea un componente de React con TypeScript para un formulario de inicio de sesi√≥n que incluya campos para correo electr√≥nico y contrase√±a. La validaci√≥n del formulario debe realizarse en el frontend usando una biblioteca de validaci√≥n de esquemas como Zod. El esquema debe validar: 1) El correo electr√≥nico, asegur√°ndose de que tenga un formato v√°lido. 2) La contrase√±a, con requisitos de al menos 8 caracteres, una letra may√∫scula, un n√∫mero y un car√°cter especial. El componente debe mostrar mensajes de error claros al usuario por cada campo que no cumpla con los requisitos. Incluye los comandos para instalar Zod y un ejemplo completo del componente y el esquema de validaci√≥n."

Categor√≠a: Optimizaci√≥n de Rendimiento
Regla #165: Lazy Loading y Code Splitting üü¢
Prompt: "Implementa lazy loading y code splitting en una aplicaci√≥n React con React Router. Muestra c√≥mo usar React.lazy() y Suspense para cargar componentes de forma diferida. Incluye ejemplos de c√≥mo dividir el c√≥digo por rutas, c√≥mo crear un componente de loading, y c√≥mo optimizar el bundle size. Explica los beneficios de rendimiento y proporciona m√©tricas de mejora esperadas."

Regla #166: Progressive Web App (PWA) üü¢
Prompt: "Configura una aplicaci√≥n React + Vite como PWA. Incluye la creaci√≥n del manifest.json con todos los campos necesarios (name, short_name, icons, theme_color, etc.), la configuraci√≥n del service worker para cache offline, y c√≥mo hacer la app instalable. Proporciona ejemplos de estrategias de cache y explica c√≥mo probar la PWA en diferentes dispositivos."

Regla #167: SEO Optimization üü¢
Prompt: "Implementa optimizaci√≥n SEO en una aplicaci√≥n React. Incluye meta tags din√°micos, Open Graph para redes sociales, Twitter Cards, structured data (JSON-LD), sitemap.xml, y robots.txt. Muestra c√≥mo usar React Helmet o similar para gestionar meta tags por p√°gina. Proporciona ejemplos completos y mejores pr√°cticas para mejorar el ranking en buscadores."

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Categor√≠a: OPTIMIZACI√ìN Y EFICIENCIA DEL FRONTEND ‚ö°
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Regla #168: Factores Clave para la Eficiencia del Proyecto üî•
Prompt: "Para que el proyecto sea eficiente, m√°s que enfocarse en el peso total en MB de la carpeta, debes priorizar los siguientes aspectos cr√≠ticos de optimizaci√≥n del frontend. Implementa y verifica que se cumplan TODOS estos puntos clave antes de considerar el proyecto optimizado."

Regla #169: Minificaci√≥n y Bundling Obligatorio üü¢
Prompt: "Aseg√∫rate de que TODOS los archivos JS y CSS est√©n minificados (espacios y comentarios eliminados) y agrupados (bundled). El HTML debe estar limpio y optimizado. Configura tu herramienta de build (Vite, Webpack, etc.) para aplicar minificaci√≥n autom√°tica en producci√≥n. Proporciona la configuraci√≥n exacta y verifica que los archivos finales no contengan c√≥digo de desarrollo, console.logs, o comentarios innecesarios."

Regla #170: Tree Shaking Riguroso üü¢
Prompt: "La herramienta de build DEBE eliminar cualquier c√≥digo o librer√≠a que no se est√© utilizando (c√≥digo muerto). Configura tree shaking en tu bundler para que analice las importaciones y elimine m√≥dulos no utilizados. Verifica que las librer√≠as importadas sean tree-shakeable (usen ES modules) y que solo se incluya el c√≥digo que realmente se ejecuta. Proporciona ejemplos de c√≥mo importar correctamente para maximizar tree shaking (import { specific } from 'library' vs import * as library)."

Regla #171: Code Splitting (Divisi√≥n de C√≥digo) Estrat√©gico üü¢
Prompt: "El JavaScript solo deber√≠a cargar el c√≥digo necesario para la pantalla actual; el resto se carga de forma diferida (lazy loading). Implementa code splitting por rutas usando React.lazy() o dynamic imports. Divide el bundle en chunks m√°s peque√±os basados en las rutas de la aplicaci√≥n. El chunk inicial debe contener solo el c√≥digo cr√≠tico para la primera carga. Proporciona una estrategia completa de code splitting con ejemplos de configuraci√≥n."

Regla #172: Lazy Loading de Im√°genes Obligatorio üü¢
Prompt: "Implementa Lazy Loading para TODAS las im√°genes que est√°n 'debajo del pliegue' (fuera de la vista inicial/above the fold). Usa el atributo loading='lazy' nativo de HTML para im√°genes, o implementa IntersectionObserver para casos m√°s avanzados. Las im√°genes cr√≠ticas (above the fold) deben tener loading='eager' o no especificar el atributo. Proporciona ejemplos de implementaci√≥n para ambos casos y explica c√≥mo determinar qu√© im√°genes est√°n 'above the fold'."

Regla #173: M√©tricas de Eficiencia Requeridas üî•
Prompt: "El proyecto debe cumplir con estas m√©tricas m√≠nimas de eficiencia antes de ser considerado optimizado:
1. First Contentful Paint (FCP): < 1.8s
2. Largest Contentful Paint (LCP): < 2.5s
3. Time to Interactive (TTI): < 3.8s
4. Total Bundle Size (JS inicial): < 200KB (gzipped)
5. Total Bundle Size (CSS inicial): < 50KB (gzipped)
6. Lighthouse Performance Score: > 90

Implementa herramientas de medici√≥n (Lighthouse, WebPageTest) y proporciona un reporte de m√©tricas antes y despu√©s de las optimizaciones."

Regla #174: Optimizaci√≥n de Assets Cr√≠ticos üü¢
Prompt: "Optimiza TODOS los assets cr√≠ticos del proyecto:
- Im√°genes: Convertir a WebP/AVIF, implementar responsive images con srcset
- Fuentes: Usar font-display: swap, preload de fuentes cr√≠ticas, subset de caracteres
- CSS: Critical CSS inline, resto en async
- JavaScript: Async/defer para scripts no cr√≠ticos

Proporciona una gu√≠a paso a paso de optimizaci√≥n para cada tipo de asset con ejemplos de c√≥digo y configuraci√≥n."

Regla #175: Verificaci√≥n de Optimizaci√≥n Pre-Deploy üî•
Prompt: "Antes de cada deploy a producci√≥n, DEBES verificar y confirmar que se cumplen TODOS estos puntos:
‚úÖ Minificaci√≥n activa (JS, CSS, HTML)
‚úÖ Tree shaking configurado y funcionando
‚úÖ Code splitting implementado por rutas
‚úÖ Lazy loading de im√°genes implementado
‚úÖ Bundle analyzer ejecutado y bundles optimizados
‚úÖ Lighthouse score > 90
‚úÖ No hay console.logs en producci√≥n
‚úÖ Source maps NO incluidos en producci√≥n (solo en staging)
‚úÖ Compression (gzip/brotli) habilitada en servidor

Crea un checklist automatizado y un script de verificaci√≥n pre-deploy que valide todos estos puntos."

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
NOTAS IMPORTANTES SOBRE EFICIENCIA:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ö†Ô∏è El peso total de la carpeta del proyecto NO es el indicador principal de eficiencia.
‚úÖ Lo que importa es: Bundle size final, tiempo de carga, m√©tricas Core Web Vitals.
üî• Un proyecto puede tener 500MB en node_modules pero servir solo 150KB al cliente.
üí° Enf√≥cate en optimizar lo que el usuario final descarga, no el tama√±o del repositorio.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê